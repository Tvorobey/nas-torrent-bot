// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"nas-torrent-bot/internal/usecase/process_message/entity"
	"sync"
)

// MessageUseCaseMock is a mock implementation of bot.MessageUseCase.
//
//	func TestSomethingThatUsesMessageUseCase(t *testing.T) {
//
//		// make and configure a mocked bot.MessageUseCase
//		mockedMessageUseCase := &MessageUseCaseMock{
//			ProcessCommandMessageFunc: func(in entity.CommandMessageIn) string {
//				panic("mock out the ProcessCommandMessage method")
//			},
//			ProcessFileMessageFunc: func(in entity.FileMessageIn) string {
//				panic("mock out the ProcessFileMessage method")
//			},
//			ProcessSimpleMessageFunc: func(in entity.SimpleMessageIn) string {
//				panic("mock out the ProcessSimpleMessage method")
//			},
//		}
//
//		// use mockedMessageUseCase in code that requires bot.MessageUseCase
//		// and then make assertions.
//
//	}
type MessageUseCaseMock struct {
	// ProcessCommandMessageFunc mocks the ProcessCommandMessage method.
	ProcessCommandMessageFunc func(in entity.CommandMessageIn) string

	// ProcessFileMessageFunc mocks the ProcessFileMessage method.
	ProcessFileMessageFunc func(in entity.FileMessageIn) string

	// ProcessSimpleMessageFunc mocks the ProcessSimpleMessage method.
	ProcessSimpleMessageFunc func(in entity.SimpleMessageIn) string

	// calls tracks calls to the methods.
	calls struct {
		// ProcessCommandMessage holds details about calls to the ProcessCommandMessage method.
		ProcessCommandMessage []struct {
			// In is the in argument value.
			In entity.CommandMessageIn
		}
		// ProcessFileMessage holds details about calls to the ProcessFileMessage method.
		ProcessFileMessage []struct {
			// In is the in argument value.
			In entity.FileMessageIn
		}
		// ProcessSimpleMessage holds details about calls to the ProcessSimpleMessage method.
		ProcessSimpleMessage []struct {
			// In is the in argument value.
			In entity.SimpleMessageIn
		}
	}
	lockProcessCommandMessage sync.RWMutex
	lockProcessFileMessage    sync.RWMutex
	lockProcessSimpleMessage  sync.RWMutex
}

// ProcessCommandMessage calls ProcessCommandMessageFunc.
func (mock *MessageUseCaseMock) ProcessCommandMessage(in entity.CommandMessageIn) string {
	if mock.ProcessCommandMessageFunc == nil {
		panic("MessageUseCaseMock.ProcessCommandMessageFunc: method is nil but MessageUseCase.ProcessCommandMessage was just called")
	}
	callInfo := struct {
		In entity.CommandMessageIn
	}{
		In: in,
	}
	mock.lockProcessCommandMessage.Lock()
	mock.calls.ProcessCommandMessage = append(mock.calls.ProcessCommandMessage, callInfo)
	mock.lockProcessCommandMessage.Unlock()
	return mock.ProcessCommandMessageFunc(in)
}

// ProcessCommandMessageCalls gets all the calls that were made to ProcessCommandMessage.
// Check the length with:
//
//	len(mockedMessageUseCase.ProcessCommandMessageCalls())
func (mock *MessageUseCaseMock) ProcessCommandMessageCalls() []struct {
	In entity.CommandMessageIn
} {
	var calls []struct {
		In entity.CommandMessageIn
	}
	mock.lockProcessCommandMessage.RLock()
	calls = mock.calls.ProcessCommandMessage
	mock.lockProcessCommandMessage.RUnlock()
	return calls
}

// ProcessFileMessage calls ProcessFileMessageFunc.
func (mock *MessageUseCaseMock) ProcessFileMessage(in entity.FileMessageIn) string {
	if mock.ProcessFileMessageFunc == nil {
		panic("MessageUseCaseMock.ProcessFileMessageFunc: method is nil but MessageUseCase.ProcessFileMessage was just called")
	}
	callInfo := struct {
		In entity.FileMessageIn
	}{
		In: in,
	}
	mock.lockProcessFileMessage.Lock()
	mock.calls.ProcessFileMessage = append(mock.calls.ProcessFileMessage, callInfo)
	mock.lockProcessFileMessage.Unlock()
	return mock.ProcessFileMessageFunc(in)
}

// ProcessFileMessageCalls gets all the calls that were made to ProcessFileMessage.
// Check the length with:
//
//	len(mockedMessageUseCase.ProcessFileMessageCalls())
func (mock *MessageUseCaseMock) ProcessFileMessageCalls() []struct {
	In entity.FileMessageIn
} {
	var calls []struct {
		In entity.FileMessageIn
	}
	mock.lockProcessFileMessage.RLock()
	calls = mock.calls.ProcessFileMessage
	mock.lockProcessFileMessage.RUnlock()
	return calls
}

// ProcessSimpleMessage calls ProcessSimpleMessageFunc.
func (mock *MessageUseCaseMock) ProcessSimpleMessage(in entity.SimpleMessageIn) string {
	if mock.ProcessSimpleMessageFunc == nil {
		panic("MessageUseCaseMock.ProcessSimpleMessageFunc: method is nil but MessageUseCase.ProcessSimpleMessage was just called")
	}
	callInfo := struct {
		In entity.SimpleMessageIn
	}{
		In: in,
	}
	mock.lockProcessSimpleMessage.Lock()
	mock.calls.ProcessSimpleMessage = append(mock.calls.ProcessSimpleMessage, callInfo)
	mock.lockProcessSimpleMessage.Unlock()
	return mock.ProcessSimpleMessageFunc(in)
}

// ProcessSimpleMessageCalls gets all the calls that were made to ProcessSimpleMessage.
// Check the length with:
//
//	len(mockedMessageUseCase.ProcessSimpleMessageCalls())
func (mock *MessageUseCaseMock) ProcessSimpleMessageCalls() []struct {
	In entity.SimpleMessageIn
} {
	var calls []struct {
		In entity.SimpleMessageIn
	}
	mock.lockProcessSimpleMessage.RLock()
	calls = mock.calls.ProcessSimpleMessage
	mock.lockProcessSimpleMessage.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"
)

// FSManagerMock is a mock implementation of process_message.FSManager.
//
//	func TestSomethingThatUsesFSManager(t *testing.T) {
//
//		// make and configure a mocked process_message.FSManager
//		mockedFSManager := &FSManagerMock{
//			MoveFunc: func(from string, to string) error {
//				panic("mock out the Move method")
//			},
//		}
//
//		// use mockedFSManager in code that requires process_message.FSManager
//		// and then make assertions.
//
//	}
type FSManagerMock struct {
	// MoveFunc mocks the Move method.
	MoveFunc func(from string, to string) error

	// calls tracks calls to the methods.
	calls struct {
		// Move holds details about calls to the Move method.
		Move []struct {
			// From is the from argument value.
			From string
			// To is the to argument value.
			To string
		}
	}
	lockMove sync.RWMutex
}

// Move calls MoveFunc.
func (mock *FSManagerMock) Move(from string, to string) error {
	if mock.MoveFunc == nil {
		panic("FSManagerMock.MoveFunc: method is nil but FSManager.Move was just called")
	}
	callInfo := struct {
		From string
		To   string
	}{
		From: from,
		To:   to,
	}
	mock.lockMove.Lock()
	mock.calls.Move = append(mock.calls.Move, callInfo)
	mock.lockMove.Unlock()
	return mock.MoveFunc(from, to)
}

// MoveCalls gets all the calls that were made to Move.
// Check the length with:
//
//	len(mockedFSManager.MoveCalls())
func (mock *FSManagerMock) MoveCalls() []struct {
	From string
	To   string
} {
	var calls []struct {
		From string
		To   string
	}
	mock.lockMove.RLock()
	calls = mock.calls.Move
	mock.lockMove.RUnlock()
	return calls
}

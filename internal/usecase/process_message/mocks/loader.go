// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	loaderEntity "nas-torrent-bot/internal/domain/loader/entity"
	"sync"
)

// LoaderMock is a mock implementation of process_message.Loader.
//
//	func TestSomethingThatUsesLoader(t *testing.T) {
//
//		// make and configure a mocked process_message.Loader
//		mockedLoader := &LoaderMock{
//			DownloadFunc: func(in loaderEntity.In) error {
//				panic("mock out the Download method")
//			},
//		}
//
//		// use mockedLoader in code that requires process_message.Loader
//		// and then make assertions.
//
//	}
type LoaderMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(in loaderEntity.In) error

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// In is the in argument value.
			In loaderEntity.In
		}
	}
	lockDownload sync.RWMutex
}

// Download calls DownloadFunc.
func (mock *LoaderMock) Download(in loaderEntity.In) error {
	if mock.DownloadFunc == nil {
		panic("LoaderMock.DownloadFunc: method is nil but Loader.Download was just called")
	}
	callInfo := struct {
		In loaderEntity.In
	}{
		In: in,
	}
	mock.lockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	mock.lockDownload.Unlock()
	return mock.DownloadFunc(in)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//
//	len(mockedLoader.DownloadCalls())
func (mock *LoaderMock) DownloadCalls() []struct {
	In loaderEntity.In
} {
	var calls []struct {
		In loaderEntity.In
	}
	mock.lockDownload.RLock()
	calls = mock.calls.Download
	mock.lockDownload.RUnlock()
	return calls
}

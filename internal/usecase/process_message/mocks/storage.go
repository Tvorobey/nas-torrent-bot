// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"
)

// StorageMock is a mock implementation of process_message.Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked process_message.Storage
//		mockedStorage := &StorageMock{
//			AddFunc: func(userID int64, chatID int64)  {
//				panic("mock out the Add method")
//			},
//			ExistsFunc: func(userID int64) bool {
//				panic("mock out the Exists method")
//			},
//		}
//
//		// use mockedStorage in code that requires process_message.Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(userID int64, chatID int64)

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(userID int64) bool

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// UserID is the userID argument value.
			UserID int64
			// ChatID is the chatID argument value.
			ChatID int64
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// UserID is the userID argument value.
			UserID int64
		}
	}
	lockAdd    sync.RWMutex
	lockExists sync.RWMutex
}

// Add calls AddFunc.
func (mock *StorageMock) Add(userID int64, chatID int64) {
	if mock.AddFunc == nil {
		panic("StorageMock.AddFunc: method is nil but Storage.Add was just called")
	}
	callInfo := struct {
		UserID int64
		ChatID int64
	}{
		UserID: userID,
		ChatID: chatID,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	mock.AddFunc(userID, chatID)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedStorage.AddCalls())
func (mock *StorageMock) AddCalls() []struct {
	UserID int64
	ChatID int64
} {
	var calls []struct {
		UserID int64
		ChatID int64
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *StorageMock) Exists(userID int64) bool {
	if mock.ExistsFunc == nil {
		panic("StorageMock.ExistsFunc: method is nil but Storage.Exists was just called")
	}
	callInfo := struct {
		UserID int64
	}{
		UserID: userID,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(userID)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedStorage.ExistsCalls())
func (mock *StorageMock) ExistsCalls() []struct {
	UserID int64
} {
	var calls []struct {
		UserID int64
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}
